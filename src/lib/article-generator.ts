import { Database, Article } from './database';
import IngestService from './ingest';
import RankingService from './ranking';
import AIService from './ai';

export interface GeneratedArticle {
  slug: string;
  title: string;
  dek?: string;
  body_html: string;
  word_count: number;
  hero_url?: string;
  lang: string;
  author_type: 'ai' | 'human';
  review_status: 'auto' | 'needs_review' | 'reviewed';
  primary_source_url?: string;
  published_at: Date;
}

export class ArticleGenerator {
  static generateSlug(title: string): string {
    const baseSlug = title
      .toLowerCase()
      .replace(/[^a-z0-9\s-]/g, '')
      .replace(/\s+/g, '-')
      .replace(/-+/g, '-')
      .trim()
      .substring(0, 100);
    
    // Add timestamp to ensure uniqueness
    const timestamp = Date.now().toString(36);
    return `${baseSlug}-${timestamp}`;
  }

  static convertToHTML(articleContent: any): string {
    const sections = articleContent.body_sections || {};
    
    let html = `
      <div class="article-content">
        <div class="summary">
          <p>${sections.summary_150w || 'Technical summary of the release'}</p>
        </div>
        
        <section class="what-changed">
          <h2>What Changed</h2>
          <ul>
            ${sections.what_changed && sections.what_changed.length > 0 
              ? sections.what_changed.map((item: string) => `<li>${item}</li>`).join('')
              : '<li>New features and improvements</li>'
            }
          </ul>
        </section>
        
        <section class="why-it-matters">
          <h2>Why It Matters</h2>
          <ul>
            ${sections.why_it_matters && sections.why_it_matters.length > 0
              ? sections.why_it_matters.map((item: string) => `<li>${item}</li>`).join('')
              : '<li>Important for development workflow</li>'
            }
          </ul>
        </section>
        
        <section class="actions">
          <h2>Action Items</h2>
          <ul>
            ${sections.actions && sections.actions.length > 0
              ? sections.actions.map((item: string) => `<li>${item}</li>`).join('')
              : '<li>Review release notes and plan upgrade</li>'
            }
          </ul>
        </section>
    `;

    if (sections.breaking_changes && sections.breaking_changes.length > 0) {
      html += `
        <section class="breaking-changes">
          <h2>‚ö†Ô∏è Breaking Changes</h2>
          <div class="warning">
            <p class="text-sm font-medium mb-3">These changes may require code modifications:</p>
            <ul>
              ${sections.breaking_changes.map((item: string) => `<li>${item}</li>`).join('')}
            </ul>
          </div>
        </section>
      `;
    }

    if (articleContent.code_snippet && articleContent.code_snippet.code) {
      html += `
        <section class="code-snippet">
          <h2>${articleContent.code_snippet.title || 'Code Example'}</h2>
          <div class="code-block">
            <pre><code class="language-${articleContent.code_snippet.lang || 'bash'}">${articleContent.code_snippet.code}</code></pre>
          </div>
        </section>
      `;
    }

    html += `
        <section class="disclaimer">
          <p><em>This analysis was generated by AI based on official release notes. Sources are linked below.</em></p>
        </section>
      </div>
    `;

    return html;
  }

  static countWords(text: string): number {
    return text.split(/\s+/).filter(word => word.length > 0).length;
  }

  static async generateDailyArticle(): Promise<Article | null> {
    try {
      console.log('Starting daily article generation...');

      // Step 1: Ingest new data
      const ingestedCount = await IngestService.runDailyIngest();
      console.log(`Ingested ${ingestedCount} new items`);

      // Step 2: Get recent raw items and rank them
      const recentItems = await Database.getRecentRawItems(100);
      const rankedItems = RankingService.rankItems(recentItems);
      
      if (rankedItems.length === 0) {
        console.log('No suitable candidates found for article generation');
        return null;
      }

      // Step 3: Select best candidate
      const selectedItem = RankingService.selectBestCandidate(rankedItems);
      if (!selectedItem) {
        console.log('No suitable candidate selected');
        return null;
      }

      console.log(`Selected candidate: ${selectedItem.title} (score: ${selectedItem.score})`);

      // Step 4: Build facts pack
      const factsPack = RankingService.buildFactsPack(selectedItem);

      // Step 5: Generate article content with AI
      const articleContent = await AIService.generateArticle(factsPack);

      // Step 6: Validate article
      const validation = await AIService.validateArticle(articleContent, factsPack);
      if (!validation.isValid) {
        console.log('Article validation failed:', validation.issues);
        // For now, we'll still proceed but mark as needs_review
      }

      // Step 7: Generate image prompt and hero image
      const imagePrompt = await AIService.generateImagePrompt(factsPack.topic);
      const heroUrl = await AIService.generateHeroImage(imagePrompt);

      // Step 8: Convert to HTML and create article
      const slug = this.generateSlug(articleContent.headline);
      const bodyHtml = this.convertToHTML(articleContent);
      const wordCount = this.countWords(bodyHtml);

      const article: GeneratedArticle = {
        slug,
        title: articleContent.headline,
        dek: articleContent.dek,
        body_html: bodyHtml,
        word_count: wordCount,
        hero_url: heroUrl || undefined,
        lang: 'en',
        author_type: 'ai',
        review_status: validation.isValid ? 'auto' : 'needs_review',
        primary_source_url: selectedItem.url || undefined,
        published_at: new Date()
      };

      // Step 9: Save to database
      const savedArticle = await Database.insertArticle(article);

      // Step 10: Save citations
      if (articleContent.citations.length > 0) {
        const citations = articleContent.citations.map(citation => ({
          article_id: savedArticle.id,
          url: citation.url,
          title: citation.title
        }));
        await Database.insertCitations(citations);
      }

      // Step 11: Attach tags
      if (articleContent.tags.length > 0) {
        await Database.attachTagsToArticle(savedArticle.id, articleContent.tags);
      }

      console.log(`Successfully generated article: ${savedArticle.slug}`);
      return savedArticle;

    } catch (error) {
      console.error('Failed to generate daily article:', error);
      return null;
    }
  }

  static async generateMultipleArticles(count: number = 3, skipIngest: boolean = false): Promise<Article[]> {
    try {
      console.log(`Starting generation of ${count} articles...`);

      // Step 1: Ingest new data (only if not skipped)
      if (!skipIngest) {
        const ingestedCount = await IngestService.runDailyIngest();
        console.log(`Ingested ${ingestedCount} new items`);
      } else {
        console.log('Skipping ingest (already done)');
      }

      // Step 2: Get recent raw items and rank them (reduced for speed)
      const recentItems = await Database.getRecentRawItems(100); // Reduced for faster processing
      const rankedItems = RankingService.rankItems(recentItems);
      
      if (rankedItems.length === 0) {
        console.log('No suitable candidates found for article generation');
        return [];
      }

      // Step 3: Use all ranked items for dynamic selection
      console.log(`Using ${rankedItems.length} ranked items for dynamic article generation`);

      const generatedArticles: Article[] = [];

      // Step 4: Generate articles for each candidate
      let generatedCount = 0;
      let currentIndex = 0;
      const usedTopics = new Set<string>(); // Track topics used in this generation session
      const usedTitles = new Set<string>(); // Track titles used in this generation session
      
      while (generatedCount < count && currentIndex < rankedItems.length) {
        const selectedItem = rankedItems[currentIndex];
        console.log(`\nüìù Generating article ${generatedCount + 1}/${count}: ${selectedItem.title} (score: ${selectedItem.score})`);

        try {
          // Check for similar recent articles to avoid duplicates
          if (selectedItem.title) {
            const similarArticles = await Database.getSimilarArticles(selectedItem.title, 7); // Last 7 days
            if (similarArticles.length > 0) {
              console.log(`‚ö†Ô∏è Skipping similar article: ${selectedItem.title} (found similar: ${similarArticles[0].title})`);
              currentIndex++;
              continue;
            }
          }

          // Check for similar titles within this generation session (more precise)
          if (selectedItem.title) {
            const normalizedTitle = selectedItem.title.toLowerCase().trim();
            const titleWords = normalizedTitle.split(/\s+/)
              .filter(word => word.length > 3)
              .filter(word => !['the', 'and', 'for', 'with', 'from', 'this', 'that', 'are', 'was', 'were', 'have', 'has', 'had', 'will', 'would', 'could', 'should', 'may', 'might', 'can', 'must', 'shall'].includes(word))
              .slice(0, 3); // Only first 3 significant words
            
            // Check if significant words from this title are already used
            const hasTitleOverlap = titleWords.some(word => 
              Array.from(usedTitles).some(usedTitle => {
                const usedWords = usedTitle.split(/\s+/)
                  .filter(w => w.length > 3)
                  .filter(w => !['the', 'and', 'for', 'with', 'from', 'this', 'that', 'are', 'was', 'were', 'have', 'has', 'had', 'will', 'would', 'could', 'should', 'may', 'might', 'can', 'must', 'shall'].includes(w))
                  .slice(0, 3);
                
                // Only consider overlap if exact word match (not partial)
                return usedWords.includes(word);
              })
            );
            
            if (hasTitleOverlap) {
              console.log(`‚ö†Ô∏è Skipping title overlap: ${selectedItem.title} (overlaps with used titles)`);
              currentIndex++;
              continue;
            }
          }

          // Check for topic overlap within this generation session (more precise)
          const topicKeywords = RankingService.extractTopicKeywords(selectedItem);
          const frameworkKeywords = RankingService.extractFrameworkKeywords(selectedItem);
          const allKeywords = [...topicKeywords, ...frameworkKeywords];
          
          // Only check for framework overlap (not all keywords)
          const hasFrameworkOverlap = frameworkKeywords.some(keyword => 
            usedTopics.has(keyword.toLowerCase())
          );
          
          if (hasFrameworkOverlap) {
            console.log(`‚ö†Ô∏è Skipping framework overlap: ${selectedItem.title} (frameworks: ${frameworkKeywords.join(', ')})`);
            currentIndex++;
            continue;
          }

          // Build facts pack
          const factsPack = RankingService.buildFactsPack(selectedItem);

          // Generate article content with AI
          const articleContent = await AIService.generateArticle(factsPack);

          // Validate article
          const validation = await AIService.validateArticle(articleContent, factsPack);
          if (!validation.isValid) {
            console.log(`‚ö†Ô∏è Article ${generatedCount + 1} validation failed:`, validation.issues);
          }

          // Generate image prompt and hero image
          const imagePrompt = await AIService.generateImagePrompt(factsPack.topic);
          const heroUrl = await AIService.generateHeroImage(imagePrompt);

          // Convert to HTML and create article
          const slug = this.generateSlug(articleContent.headline);
          const bodyHtml = this.convertToHTML(articleContent);
          const wordCount = this.countWords(bodyHtml);

          const article: GeneratedArticle = {
            slug,
            title: articleContent.headline,
            dek: articleContent.dek,
            body_html: bodyHtml,
            word_count: wordCount,
            hero_url: heroUrl || undefined,
            lang: 'en',
            author_type: 'ai',
            review_status: validation.isValid ? 'auto' : 'needs_review',
            primary_source_url: selectedItem.url || undefined,
            published_at: new Date()
          };

          // Save to database
          const savedArticle = await Database.insertArticle(article);

          // Save citations
          if (articleContent.citations.length > 0) {
            const citations = articleContent.citations.map(citation => ({
              article_id: savedArticle.id,
              url: citation.url,
              title: citation.title
            }));
            await Database.insertCitations(citations);
          }

          // Attach tags
          if (articleContent.tags.length > 0) {
            await Database.attachTagsToArticle(savedArticle.id, articleContent.tags);
          }

          generatedArticles.push(savedArticle);
          generatedCount++;
          
          // Mark frameworks and titles as used to avoid duplicates in this session
          frameworkKeywords.forEach(keyword => usedTopics.add(keyword.toLowerCase()));
          if (selectedItem.title) {
            usedTitles.add(selectedItem.title.toLowerCase().trim());
          }
          
          console.log(`‚úÖ Successfully generated article ${generatedCount}: ${savedArticle.slug}`);

          // Add delay between articles to avoid rate limiting (reduced for speed)
          if (generatedCount < count) {
            console.log('‚è≥ Waiting 1 second before next article...');
            await new Promise(resolve => setTimeout(resolve, 1000));
          }

        } catch (error) {
          console.error(`‚ùå Failed to generate article ${generatedCount + 1}:`, error);
          // Continue with next article instead of failing completely
        }
        
        currentIndex++;
      }

      console.log(`\nüéâ Successfully generated ${generatedArticles.length} articles out of ${count} requested`);
      return generatedArticles;

    } catch (error) {
      console.error('Failed to generate multiple articles:', error);
      return [];
    }
  }

  static async runQualityChecks(): Promise<void> {
    console.log('Running quality checks...');

    // Check for articles that need review
    const needsReview = await Database.query(
      'SELECT * FROM articles WHERE review_status = \'needs_review\' ORDER BY created_at DESC LIMIT 10'
    );

    if (needsReview.rows.length > 0) {
      console.log(`Found ${needsReview.rows.length} articles that need review`);
      
      // Here you could implement additional quality checks:
      // - Link validation
      // - Content analysis
      // - Fact checking
      // - SEO optimization
    }

    // Check for broken citations
    const citations = await Database.query(
      'SELECT c.*, a.title as article_title FROM citations c JOIN articles a ON c.article_id = a.id WHERE a.published_at > NOW() - INTERVAL \'7 days\''
    );

    for (const citation of citations.rows) {
      try {
        const response = await fetch(citation.url, { method: 'HEAD' });
        if (!response.ok) {
          console.log(`Broken citation found: ${citation.url} in article "${citation.article_title}"`);
        }
      } catch (error) {
        console.log(`Failed to check citation: ${citation.url}`);
      }
    }
  }
}

export default ArticleGenerator;
